<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pluberty Protoype</title>
    <style>
        body { margin: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background: #f0f0f0; }
        canvas { border: 1px solid black; touch-action: none; }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="400" height="800"></canvas>
    <script>
        // Get canvas and context for rendering
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game state variables
        // Ball: position, velocity, and collision tracking
        // Obstacles, pegs, slots, walls: game objects
        // Coins, clusters: collectibles for points and power-ups
        // Score, round, game state: track progress and game mode
        let ball = { x: 100, y: 200, radius: 10, vy: 0, vx: 2, lastPegHit: null, stuckCounter: 0, lastCollisionTime: 0 };
        let obstacles = [];
        let pegs = [];
        let slots = [];
        let walls = [];
        let coins = [];
        let triangleClusters = [];
        let coinClusters = [];
        let tripleBulletClusters = [];
        let shotTriangles = [];
        let blueShotTriangles = [];
        let scorePopups = [];
        let coinBadge = null;
        let tripleBulletBadge = null;
        let score = 0;
        let totalScore = 0;
        let round = 1;
        let bulletCount = 0;
        let gameState = 'menu';
        let lastTime = performance.now();
        let obstacleRadiusIncrement = 10;
        let hasTrianglePower = false;
        let gameTime = 0;
        let coinBoostTimer = 0;
        let coinBoostActive = false;
        let tripleBulletActive = false;
        let tripleBulletTimer = 0;
        let slotCount = 0;
        let selectedRandomizer = null;
        let randomizerOptions = [];
        let mouseX = 0;
        let mouseY = 0;

        // Game constants
        // Physics: gravity, jump strength, collision parameters
        // Sizes: ball, pegs, slots, obstacles, coins
        // Scoring: points for coins, obstacles, slots
        // Timing: durations for pop-ups, badges, boosts
        // Probabilities: spawn chances for collectibles and shooting obstacles
        const GRAVITY = 0.3;
        const JUMP = -4;
        const PEG_RADIUS = 5;
        const PEG_SECTION_TOP = 585;
        const SLOT_WIDTH = 85;
        const SLOT_HEIGHT = 50;
        const WALL_WIDTH = 5;
        const WALL_HEIGHT = 50;
        const BOUNCE_FACTOR = 0.5;
        const BOUNCE_HORIZONTAL_NUDGE = 3;
        const MIN_BOUNCE_SPEED = 1.5;
        const HORIZONTAL_BOOST = 1.3;
        const OBSTACLE_MIN_RADIUS = 10;
        const OBSTACLE_MAX_RADIUS = 50;
        const OBSTACLE_SPACING = 100;
        const COIN_RADIUS = 10;
        const COIN_POINTS = 50;
        const TRIANGLE_RADIUS = 10;
        const TRIANGLE_SHOT_SIZE = 5;
        const SCORE_POPUP_DURATION = 2.0;
        const SCORE_POPUP_SPEED = 50;
        const MAX_BULLETS = 100;
        const BULLET_RELOAD = 25;
        const HIGH_VALUE_CHANCE = 0.075;
        const HIGH_VALUE_MIN = 1000;
        const HIGH_VALUE_MAX = 8000;
        const STUCK_THRESHOLD = 2;
        const STUCK_TIME_LIMIT = 0.5;
        const COIN_SPAWN_CHANCE = 0.005;
        const TRIANGLE_SPAWN_CHANCE = 0.0025;
        const COIN_CLUSTER_SPAWN_CHANCE = 0.00125;
        const TRIPLE_BULLET_SPAWN_CHANCE = 0.00125;
        const COIN_BOOST_DURATION = 5;
        const COIN_BOOST_MULTIPLIER = 25;
        const TRIPLE_BULLET_DURATION = 5;
        const SHOOTING_OBSTACLE_CHANCE = 0.025;
        const SHOOTING_INTERVAL = 2.35;
        const BADGE_DURATION = 3.0;

        // Randomizer definitions
        const RANDOMIZERS = [
            {
                name: "Fewer Pegs",
                description: "Half the pegs, evenly distributed.",
                apply: () => {
                    // Applied in initScoringGrid
                },
                modifyConstants: () => ({})
            },
            {
                name: "2x Bullets",
                description: "Double bullets on upgrades.",
                apply: () => {
                    // hasTrianglePower = bulletCount > 0;
                },
                modifyConstants: () => ({
                    BULLET_RELOAD: 100,
                    MAX_BULLETS: 200
                })
            },
            {
                name: "Small Obstacles",
                description: "Obstacles max at size 30.",
                apply: () => {},
                modifyConstants: () => ({ OBSTACLE_MAX_RADIUS: 30 })
            },
            {
                name: "No Shooting Obstacles",
                description: "No obstacles shoot bullets.",
                apply: () => {},
                modifyConstants: () => ({ SHOOTING_OBSTACLE_CHANCE: 0 })
            },
            {
                name: "More Upgrades",
                description: "Upgrades spawn more frequently.",
                apply: () => {},
                modifyConstants: () => ({
                    TRIANGLE_SPAWN_CHANCE: TRIANGLE_SPAWN_CHANCE * 1.5,
                    COIN_CLUSTER_SPAWN_CHANCE: COIN_CLUSTER_SPAWN_CHANCE * 1.5,
                    TRIPLE_BULLET_SPAWN_CHANCE: TRIPLE_BULLET_SPAWN_CHANCE * 1.5
                })
            }
        ];

        // Initialize randomizer menu
        function initRandomizerMenu() {
            const shuffled = [...RANDOMIZERS].sort(() => Math.random() - 0.5);
            randomizerOptions = shuffled.slice(0, 3).map((randomizer, index) => ({
                ...randomizer,
                x: 50,
                y: 300 + index * 150,
                width: 300,
                height: 100
            }));
        }

        // Initialize obstacles for top section
        function initObstacles() {
            obstacles = [];
            coins = [];
            triangleClusters = [];
            coinClusters = [];
            tripleBulletClusters = [];
            const effectiveMaxRadius = selectedRandomizer && selectedRandomizer.name === "Small Obstacles" ? 30 : OBSTACLE_MAX_RADIUS;
            const effectiveShootingChance = selectedRandomizer && selectedRandomizer.name === "No Shooting Obstacles" ? 0 : SHOOTING_OBSTACLE_CHANCE;
            const effectiveTriangleSpawnChance = selectedRandomizer && selectedRandomizer.name === "More Upgrades" ? TRIANGLE_SPAWN_CHANCE * 1.5 : TRIANGLE_SPAWN_CHANCE;
            const effectiveCoinClusterSpawnChance = selectedRandomizer && selectedRandomizer.name === "More Upgrades" ? COIN_CLUSTER_SPAWN_CHANCE * 1.5 : COIN_CLUSTER_SPAWN_CHANCE;
            const effectiveTripleBulletSpawnChance = selectedRandomizer && selectedRandomizer.name === "More Upgrades" ? TRIPLE_BULLET_SPAWN_CHANCE * 1.5 : TRIPLE_BULLET_SPAWN_CHANCE;
            
            for (let i = 0; i < 8; i++) {
                const isShooting = Math.random() < effectiveShootingChance * (1 + gameTime / 30 * 9);
                obstacles.push({
                    x: 400 + i * (OBSTACLE_SPACING + 2 * effectiveMaxRadius + 10),
                    y: Math.random() * (canvas.height * 2 / 3 - effectiveMaxRadius * 2) + effectiveMaxRadius,
                    radius: OBSTACLE_MIN_RADIUS,
                    isShooting: isShooting,
                    shootTimer: isShooting ? Math.random() * SHOOTING_INTERVAL : 0
                });
            }
            // Spawn initial collectibles with low probability
            if (Math.random() < 0.25) {
                triangleClusters.push({
                    x: canvas.width + Math.random() * 100 + TRIANGLE_RADIUS,
                    y: Math.random() * (canvas.height * 2 / 3 - TRIANGLE_RADIUS * 2) + TRIANGLE_RADIUS
                });
            }
            if (Math.random() < 0.125) {
                coinClusters.push({
                    x: canvas.width + Math.random() * 100 + COIN_RADIUS,
                    y: Math.random() * (canvas.height * 2 / 3 - COIN_RADIUS * 2) + COIN_RADIUS
                });
            }
            if (Math.random() < 0.125) {
                tripleBulletClusters.push({
                    x: canvas.width + Math.random() * 100 + TRIANGLE_RADIUS,
                    y: Math.random() * (canvas.height * 2 / 3 - TRIANGLE_RADIUS * 2) + TRIANGLE_RADIUS
                });
            }
        }

        // Initialize scoring pegs, slots, and walls for scoring section
        function initScoringGrid() {
            if (selectedRandomizer && selectedRandomizer.name === "Fewer Pegs") {
                
                pegs = [];
                colAdjust = selectedRandomizer && selectedRandomizer.name === "Fewer Pegs" ? 34 : 28;
                xAdjust = selectedRandomizer && selectedRandomizer.name === "Fewer Pegs" ? 100 : 80;
                rows = 6;
                for (let row = 0; row < rows; row++) {
                    const y = PEG_SECTION_TOP + row * colAdjust;
                    const x = xAdjust + (row % 2 === 0 ? -colAdjust : colAdjust);
                    pegs.push({ x, y, radius: PEG_RADIUS });
                }
            } else {
                pegs = [];
                const rows = 6;
                const cols = 8;
                // Create a fixed 4x8 grid of pegs
                for (let row = 0; row < rows; row++) {
                    const y = PEG_SECTION_TOP + row * 28;
                    for (let col = 0; col < cols; col++) {
                        const x = 40 + col * 80 + (row % 2 === 0 ? -20 : 20);
                        pegs.push({ x, y, radius: PEG_RADIUS });
                    }
                }
            }
            slots = [];
            walls = [];
            // Create 6 initial slots with progressive or high-value points
            for (let i = 0; i < 6; i++) {
                slotCount++;
                const isHighValue = Math.random() < HIGH_VALUE_CHANCE;
                let points = isHighValue ? Math.round((Math.random() * (HIGH_VALUE_MAX - HIGH_VALUE_MIN) + HIGH_VALUE_MIN) / 100) * 100 : (slotCount < 10 ? 5 : 5 * (slotCount - 9));
                slots.push({
                    x: i * SLOT_WIDTH,
                    y: canvas.height - SLOT_HEIGHT,
                    width: SLOT_WIDTH,
                    height: SLOT_HEIGHT,
                    points: points
                });
                // Add walls between slots
                if (i < 9) {
                    walls.push({
                        x: (i + 1) * SLOT_WIDTH - WALL_WIDTH / 2,
                        y: canvas.height - SLOT_HEIGHT,
                        width: WALL_WIDTH,
                        height: WALL_HEIGHT
                    });
                }
            }
        }

        // Reset game for next round
        function resetGame() {
            // Reset ball position and state
            ball = { x: 100, y: 200, radius: 10, vy: 0, vx: 2, lastPegHit: null, stuckCounter: 0, lastCollisionTime: 0 };
            score = 0;
            gameState = 'playing';
            obstacleRadiusIncrement = 10;
            hasTrianglePower = false;
            tripleBulletActive = false;
            tripleBulletTimer = 0;
            shotTriangles = [];
            blueShotTriangles = [];
            scorePopups = [];
            coinBadge = null;
            tripleBulletBadge = null;
            bulletCount = 0;
            gameTime = 0;
            coinBoostTimer = 0;
            coinBoostActive = false;
            slotCount = 0;
            // Increment round if not final
            if (round < 3) {
                round += 1;
            }
            initObstacles();
            initScoringGrid();
            // // TRAVIS
            // if (selectedRandomizer && selectedRandomizer.name === "2x Bullets") {
            //     hasTrianglePower = bulletCount > 0;
            // }
        }

        // Full reset after final round (round 3)
        function fullResetGame() {
            // Reset all game state
            ball = { x: 100, y: 200, radius: 10, vy: 0, vx: 2, lastPegHit: null, stuckCounter: 0, lastCollisionTime: 0 };
            score = 0;
            totalScore = 0;
            round = 1;
            gameState = 'menu';
            obstacleRadiusIncrement = 10;
            hasTrianglePower = false;
            tripleBulletActive = false;
            tripleBulletTimer = 0;
            shotTriangles = [];
            blueShotTriangles = [];
            scorePopups = [];
            coinBadge = null;
            tripleBulletBadge = null;
            bulletCount = 0;
            gameTime = 0;
            coinBoostTimer = 0;
            coinBoostActive = false;
            slotCount = 0;
            selectedRandomizer = null;
            initRandomizerMenu();
        }

        // Handle keyboard input
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && gameState === 'playing') {
                // Apply jump in top section
                ball.vy = JUMP;
                if (hasTrianglePower && bulletCount > 0) {
                    // Fire bullets if powered up
                    if (tripleBulletActive) {
                        shotTriangles.push(
                            { x: ball.x + ball.radius, y: ball.y - 10, vx: 5 },
                            { x: ball.x + ball.radius, y: ball.y, vx: 5 },
                            { x: ball.x + ball.radius, y: ball.y + 10, vx: 5 }
                        );
                        // bulletCount -= 1;
                    } else {
                        shotTriangles.push({
                            x: ball.x + ball.radius,
                            y: ball.y,
                            vx: 5
                        });
                        bulletCount -= 1;
                    }
                }
            }
            if (e.code === 'KeyR' && gameState === 'scoring' && round < 3) {
                resetGame();
            }
            if (e.code === 'KeyS' && gameState === 'scoring' && round === 3) {
                fullResetGame();
            }
        });

        // Handle touch input for mobile users
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const touchX = touch.clientX - rect.left;
            const touchY = touch.clientY - rect.top;
            if (gameState === 'menu') {
                randomizerOptions.forEach(option => {
                    if (touchX >= option.x && touchX <= option.x + option.width &&
                        touchY >= option.y && touchY <= option.y + option.height) {
                        selectedRandomizer = option;
                        selectedRandomizer.apply();
                        gameState = 'playing';
                        initObstacles();
                        initScoringGrid();
                    }
                });
            } else if (gameState === 'playing') {
                ball.vy = JUMP;
                if (hasTrianglePower && bulletCount > 0) {
                    if (tripleBulletActive) {
                        shotTriangles.push(
                            { x: ball.x + ball.radius, y: ball.y - 10, vx: 5 },
                            { x: ball.x + ball.radius, y: ball.y, vx: 5 },
                            { x: ball.x + ball.radius, y: ball.y + 10, vx: 5 }
                        );
                        // bulletCount -= 1;
                    } else {
                        shotTriangles.push({
                            x: ball.x + ball.radius,
                            y: ball.y,
                            vx: 5
                        });
                        bulletCount -= 1;
                    }
                }
            } else if (gameState === 'scoring') {
                if (round < 3) {
                    resetGame();
                } else {
                    fullResetGame();
                }
            }
        });

        // Update game state (physics, collisions, spawning)
        function update(deltaTime) {
            if (gameState === 'menu') {
                return;
            }

            // Update game timers
            gameTime += deltaTime;
            if (coinBoostActive) {
                coinBoostTimer -= deltaTime;
                if (coinBoostTimer <= 0) {
                    coinBoostActive = false;
                }
            }
            if (tripleBulletActive) {
                tripleBulletTimer -= deltaTime;
                if (tripleBulletTimer <= 0) {
                    tripleBulletActive = false;
                }
            }

            // Update coin badge animation (fade in/out)
            if (coinBadge) {
                coinBadge.timer += deltaTime;
                if (coinBadge.state === 'fadeIn') {
                    coinBadge.alpha += 2 * deltaTime;
                    if (coinBadge.alpha >= 1) {
                        coinBadge.alpha = 1;
                        coinBadge.state = 'stay';
                    }
                } else if (coinBadge.state === 'stay' && coinBadge.timer >= BADGE_DURATION) {
                    coinBadge.state = 'fadeOut';
                } else if (coinBadge.state === 'fadeOut') {
                    coinBadge.alpha -= 2 * deltaTime;
                    if (coinBadge.alpha <= 0) {
                        coinBadge = null;
                    }
                }
            }

            // Update bullet badge animation (fade in/out)
            if (tripleBulletBadge) {
                tripleBulletBadge.timer += deltaTime;
                if (tripleBulletBadge.state === 'fadeIn') {
                    tripleBulletBadge.alpha += 2 * deltaTime;
                    if (tripleBulletBadge.alpha >= 1) {
                        tripleBulletBadge.alpha = 1;
                        tripleBulletBadge.state = 'stay';
                    }
                } else if (tripleBulletBadge.state === 'stay' && tripleBulletBadge.timer >= BADGE_DURATION) {
                    tripleBulletBadge.state = 'fadeOut';
                } else if (tripleBulletBadge.state === 'fadeOut') {
                    tripleBulletBadge.alpha -= 2 * deltaTime;
                    if (tripleBulletBadge.alpha <= 0) {
                        tripleBulletBadge = null;
                    }
                }
            }

            // Update score pop-ups (fade and move up)
            scorePopups = scorePopups.filter(popup => {
                popup.y -= SCORE_POPUP_SPEED * deltaTime;
                popup.timer -= deltaTime;
                popup.alpha = popup.timer / SCORE_POPUP_DURATION;
                return popup.timer > 0;
            });

            if (gameState === 'playing') {
                const effectiveMaxRadius = selectedRandomizer && selectedRandomizer.name === "Small Obstacles" ? 30 : OBSTACLE_MAX_RADIUS;
                const effectiveShootingChance = selectedRandomizer && selectedRandomizer.name === "No Shooting Obstacles" ? 0 : SHOOTING_OBSTACLE_CHANCE;
                const effectiveTriangleSpawnChance = selectedRandomizer && selectedRandomizer.name === "More Upgrades" ? TRIANGLE_SPAWN_CHANCE * 1.5 : TRIANGLE_SPAWN_CHANCE;
                const effectiveCoinClusterSpawnChance = selectedRandomizer && selectedRandomizer.name === "More Upgrades" ? COIN_CLUSTER_SPAWN_CHANCE * 1.5 : COIN_CLUSTER_SPAWN_CHANCE;
                const effectiveTripleBulletSpawnChance = selectedRandomizer && selectedRandomizer.name === "More Upgrades" ? TRIPLE_BULLET_SPAWN_CHANCE * 1.5 : TRIPLE_BULLET_SPAWN_CHANCE;
                const effectiveCoinSpawnChance = coinBoostActive ? COIN_SPAWN_CHANCE * COIN_BOOST_MULTIPLIER : COIN_SPAWN_CHANCE;

                ball.y += ball.vy;
                ball.vy += GRAVITY * deltaTime * 60;

                // Scroll obstacles and check for collisions
                obstacles.forEach(obstacle => {
                    obstacle.x -= ball.vx;
                    if (obstacle.isShooting && obstacle.x > ball.x) {
                        obstacle.shootTimer -= deltaTime;
                        if (obstacle.shootTimer <= 0) {
                            // Fire blue triangle at ball
                            const dx = ball.x - obstacle.x;
                            const dy = ball.y - obstacle.y;
                            const angle = Math.atan2(dy, dx);
                            const speed = 3;
                            blueShotTriangles.push({
                                x: obstacle.x,
                                y: obstacle.y,
                                vx: Math.cos(angle) * speed,
                                vy: Math.sin(angle) * speed,
                                angle: angle + Math.PI
                            });
                            obstacle.shootTimer = SHOOTING_INTERVAL;
                        }
                    }
                });

                // Scroll collectibles and game objects
                coins.forEach(coin => { coin.x -= ball.vx; });
                triangleClusters.forEach(cluster => { cluster.x -= ball.vx; });
                coinClusters.forEach(cluster => { cluster.x -= ball.vx; });
                tripleBulletClusters.forEach(cluster => { cluster.x -= ball.vx; });
                pegs.forEach(peg => { peg.x -= ball.vx; });
                slots.forEach(slot => { slot.x -= ball.vx; });
                walls.forEach(wall => { wall.x -= ball.vx; });

                // Check obstacle collisions
                obstacles.forEach(obstacle => {
                    const dx = ball.x - obstacle.x;
                    const dy = ball.y - obstacle.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < ball.radius + obstacle.radius) {
                        gameState = 'falling';
                    }
                });

                // Check peg collisions (triggers falling state)
                pegs.forEach((peg, index) => {
                    const dx = ball.x - peg.x;
                    const dy = ball.y - peg.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < ball.radius + peg.radius && ball.lastPegHit !== index) {
                        gameState = 'falling';
                        ball.lastPegHit = index;
                        ball.lastCollisionTime = gameTime;
                        ball.stuckCounter = 1;

                        // Adjust position to resolve overlap
                        const angle = Math.atan2(dy, dx);
                        const overlap = ball.radius + peg.radius - distance + 0.5;
                        ball.x += Math.cos(angle) * overlap;
                        ball.y += Math.sin(angle) * overlap;

                        // Ensure no overlap after adjustment
                        const newDx = ball.x - peg.x;
                        const newDy = ball.y - peg.y;
                        const newDistance = Math.sqrt(newDx * newDx + newDy * newDy);
                        if (newDistance < ball.radius + peg.radius) {
                            const extraOverlap = ball.radius + peg.radius - newDistance + 0.2;
                            ball.x += Math.cos(angle) * extraOverlap;
                            ball.y += Math.sin(angle) * extraOverlap;
                        }

                        // Apply bounce physics with random horizontal nudge
                        const speed = Math.max(Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy) * BOUNCE_FACTOR, MIN_BOUNCE_SPEED);
                        const horizontalFactor = Math.abs(Math.cos(angle)) * HORIZONTAL_BOOST;
                        ball.vx = -Math.cos(angle) * speed * horizontalFactor + (Math.random() - 0.5) * BOUNCE_HORIZONTAL_NUDGE;
                        ball.vy = -Math.abs(ball.vy) * BOUNCE_FACTOR - MIN_BOUNCE_SPEED * 0.5 + (Math.random() - 0.5) * 0.3;
                    }
                });

                // Check slot collisions (ends round)
                slots.forEach(slot => {
                    if (ball.x > slot.x && ball.x < slot.x + slot.width &&
                        ball.y > slot.y && ball.y < slot.y + slot.height) {
                        score += slot.points;
                        totalScore += slot.points;
                        scorePopups.push({
                            x: 200,
                            y: 50,
                            text: `+${slot.points}`,
                            timer: SCORE_POPUP_DURATION,
                            alpha: 1,
                            fontSize: 22
                        });
                        gameState = 'scoring';
                    }
                });

                // Update blue shot triangles and check collisions
                blueShotTriangles = blueShotTriangles.filter(triangle => {
                    triangle.x += triangle.vx;
                    triangle.y += triangle.vy;
                    const dx = ball.x - triangle.x;
                    const dy = ball.y - triangle.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < ball.radius + TRIANGLE_SHOT_SIZE && gameState === 'playing') {
                        gameState = 'falling';
                        return false;
                    }
                    return triangle.x > 0 && triangle.y > 0 && triangle.y < canvas.height;
                });

                // Collect coins
                coins = coins.filter(coin => {
                    const dx = ball.x - coin.x;
                    const dy = ball.y - coin.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < ball.radius + COIN_RADIUS) {
                        score += COIN_POINTS;
                        totalScore += COIN_POINTS;
                        scorePopups.push({
                            x: 200,
                            y: 50,
                            text: `+${COIN_POINTS}`,
                            timer: SCORE_POPUP_DURATION,
                            alpha: 1,
                            fontSize: 22
                        });
                        return false;
                    }
                    return true;
                });

                // Collect triangle clusters (bullet power-up)
                triangleClusters = triangleClusters.filter(cluster => {
                    const dx = ball.x - cluster.x;
                    const dy = ball.y - cluster.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < ball.radius + TRIANGLE_RADIUS && gameState === 'playing') {
                        bulletCount = selectedRandomizer && selectedRandomizer.name === "2x Bullets" ? Math.min((bulletCount + BULLET_RELOAD) * 2, MAX_BULLETS) : Math.min(bulletCount + BULLET_RELOAD, MAX_BULLETS);
                        hasTrianglePower = true;
                        return false;
                    }
                    return true;
                });

                // Collect coin clusters (coin boost)
                coinClusters = coinClusters.filter(cluster => {
                    const dx = ball.x - cluster.x;
                    const dy = ball.y - cluster.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < ball.radius + COIN_RADIUS && gameState === 'playing') {
                        coinBoostActive = true;
                        coinBoostTimer = COIN_BOOST_DURATION;
                        coinBadge = { x: 330, y: 30, timer: 0, state: 'fadeIn', alpha: 0 };
                        return false;
                    }
                    return true;
                });

                // Collect triple bullet clusters
                tripleBulletClusters = tripleBulletClusters.filter(cluster => {
                    const dx = ball.x - cluster.x;
                    const dy = ball.y - cluster.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < ball.radius + TRIANGLE_RADIUS && gameState === 'playing') {
                        tripleBulletActive = true;
                        tripleBulletTimer = TRIPLE_BULLET_DURATION;
                        bulletCount = selectedRandomizer && selectedRandomizer.name === "2x Bullets" ? Math.min((bulletCount + BULLET_RELOAD) * 2, MAX_BULLETS) : Math.min(bulletCount + BULLET_RELOAD, MAX_BULLETS);
                        hasTrianglePower = true;
                        tripleBulletBadge = { x: 330, y: 80, timer: 0, state: 'fadeIn', alpha: 0 };
                        return false;
                    }
                    return true;
                });

                // Update player-shot triangles and obstacle hits
                shotTriangles = shotTriangles.filter(triangle => {
                    triangle.x += triangle.vx;
                    let keepTriangle = triangle.x < canvas.width;
                    obstacles = obstacles.filter(obstacle => {
                        const dx = triangle.x - obstacle.x;
                        const dy = triangle.y - obstacle.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < TRIANGLE_SHOT_SIZE + obstacle.radius) {
                            const originalRadius = obstacle.radius;
                            obstacle.radius = Math.max(obstacle.radius - 5, OBSTACLE_MIN_RADIUS);
                            let points = obstacle.isShooting && obstacle.radius <= OBSTACLE_MIN_RADIUS ? 500 : (originalRadius > 30 && obstacle.radius <= OBSTACLE_MIN_RADIUS ? 200 : 5);
                            totalScore += points;
                            scorePopups.push({
                                x: obstacle.x,
                                y: obstacle.y - obstacle.radius,
                                text: `+${points}`,
                                timer: SCORE_POPUP_DURATION,
                                alpha: 1,
                                fontSize: points === 500 ? 32 : 22
                            });
                            scorePopups.push({
                                x: 200,
                                y: 50,
                                text: `+${points}`,
                                timer: SCORE_POPUP_DURATION,
                                alpha: 1,
                                fontSize: points === 500 ? 32 : 22
                            });
                            if (obstacle.radius <= OBSTACLE_MIN_RADIUS) {
                                return false;
                            }
                            keepTriangle = false;
                        }
                        return true;
                    });
                    return keepTriangle;
                });

                // Spawn new obstacles and collectibles
                if (obstacles.length > 0 && obstacles[0].x < -obstacles[0].radius * 2) {
                    obstacles.shift();
                    obstacleRadiusIncrement = Math.min(obstacleRadiusIncrement + (Math.random() * 3 + 2), effectiveMaxRadius);
                    const isShooting = Math.random() < effectiveShootingChance * (1 + gameTime / 30 * 9);
                    obstacles.push({
                        x: canvas.width + obstacleRadiusIncrement,
                        y: Math.random() * (canvas.height * 2 / 3 - obstacleRadiusIncrement * 2) + effectiveMaxRadius,
                        radius: obstacleRadiusIncrement,
                        isShooting: isShooting,
                        shootTimer: isShooting ? Math.random() * SHOOTING_INTERVAL : 0
                    });
                    if (Math.random() < effectiveCoinSpawnChance) {
                        coins.push({
                            x: canvas.width + COIN_RADIUS,
                            y: Math.random() * (canvas.height * 2 / 3 - COIN_RADIUS * 2) + COIN_RADIUS
                        });
                    }
                    if (Math.random() < effectiveTriangleSpawnChance) {
                        triangleClusters.push({
                            x: canvas.width + TRIANGLE_RADIUS,
                            y: Math.random() * (canvas.height * 2 / 3 - TRIANGLE_RADIUS * 2) + TRIANGLE_RADIUS
                        });
                    }
                    if (Math.random() < effectiveCoinClusterSpawnChance) {
                        coinClusters.push({
                            x: canvas.width + COIN_RADIUS,
                            y: Math.random() * (canvas.height * 2 / 3 - COIN_RADIUS * 2) + COIN_RADIUS
                        });
                    }
                    if (Math.random() < effectiveTripleBulletSpawnChance) {
                        tripleBulletClusters.push({
                            x: canvas.width + TRIANGLE_RADIUS,
                            y: Math.random() * (canvas.height * 2 / 3 - TRIANGLE_RADIUS * 2) + TRIANGLE_RADIUS
                        });
                    }
                }

                // Spawn additional obstacles between 10-30 seconds
                if (gameTime > 10 && gameTime <= 30 && gameTime % 2 < deltaTime) {
                    const isShooting = Math.random() < effectiveShootingChance * (1 + gameTime / 30 * 9);
                    obstacles.push({
                        x: canvas.width + obstacleRadiusIncrement,
                        y: Math.random() * (canvas.height * 2 / 3 - obstacleRadiusIncrement * 2) + effectiveMaxRadius,
                        radius: obstacleRadiusIncrement,
                        isShooting: isShooting,
                        shootTimer: isShooting ? Math.random() * SHOOTING_INTERVAL : 0
                    });
                }

                // Spawn collectibles based on coin boost
                if (Math.random() < effectiveCoinSpawnChance) {
                    coins.push({
                        x: canvas.width + COIN_RADIUS,
                        y: Math.random() * (canvas.height * 2 / 3 - COIN_RADIUS * 2) + COIN_RADIUS
                    });
                }
                if (Math.random() < effectiveTriangleSpawnChance) {
                    triangleClusters.push({
                        x: canvas.width + TRIANGLE_RADIUS,
                        y: Math.random() * (canvas.height * 2 / 3 - TRIANGLE_RADIUS * 2) + TRIANGLE_RADIUS
                    });
                }
                if (Math.random() < effectiveCoinClusterSpawnChance) {
                    coinClusters.push({
                        x: canvas.width + COIN_RADIUS,
                        y: Math.random() * (canvas.height * 2 / 3 - COIN_RADIUS * 2) + COIN_RADIUS
                    });
                }
                if (Math.random() < effectiveTripleBulletSpawnChance) {
                    tripleBulletClusters.push({
                        x: canvas.width + TRIANGLE_RADIUS,
                        y: Math.random() * (canvas.height * 2 / 3 - TRIANGLE_RADIUS * 2) + TRIANGLE_RADIUS
                    });
                }

                // Spawn new pegs to ensure continuous scoring board
                pegs = pegs.filter(peg => peg.x + PEG_RADIUS > -125);
                const rightmostPegX = Math.max(...pegs.map(peg => peg.x), 0);
                if (rightmostPegX < canvas.width + 80) {
                    colAdjust = selectedRandomizer && selectedRandomizer.name === "Fewer Pegs" ? 34 : 28;
                    xAdjust = selectedRandomizer && selectedRandomizer.name === "Fewer Pegs" ? 100 : 80;
                    rows = 6;
                    for (let row = 0; row < rows; row++) {
                        const y = PEG_SECTION_TOP + row * colAdjust;
                        const x = rightmostPegX + xAdjust + (row % 2 === 0 ? -colAdjust : colAdjust);
                        pegs.push({ x, y, radius: PEG_RADIUS });
                    }
                }

                // Manage slots and walls
                slots = slots.filter(slot => slot.x + SLOT_WIDTH > 0);
                walls = walls.filter(wall => wall.x + WALL_WIDTH > 0);
                const rightmostSlotX = Math.max(...slots.map(slot => slot.x), 0);
                if (rightmostSlotX < canvas.width) {
                    slotCount++;
                    const isHighValue = Math.random() < HIGH_VALUE_CHANCE;
                    let newPoints = isHighValue ? Math.round((Math.random() * (HIGH_VALUE_MAX - HIGH_VALUE_MIN) + HIGH_VALUE_MIN) / 100) * 100 : (slotCount < 10 ? 5 : 5 * (slotCount - 9));
                    slots.push({
                        x: rightmostSlotX + SLOT_WIDTH,
                        y: canvas.height - SLOT_HEIGHT,
                        width: SLOT_WIDTH,
                        height: SLOT_HEIGHT,
                        points: newPoints
                    });
                    if (slots.length > 1) {
                        walls.push({
                            x: rightmostSlotX + SLOT_WIDTH - WALL_WIDTH / 2,
                            y: canvas.height - SLOT_HEIGHT,
                            width: WALL_WIDTH,
                            height: WALL_HEIGHT
                        });
                    }
                }

                // Prevent ball from going above canvas
                if (ball.y - ball.radius < 0) ball.y = ball.radius;
            } else if (gameState === 'falling') {
                // Update ball physics for scoring section
                ball.y += ball.vy;
                ball.x += ball.vx;
                ball.vy += GRAVITY * deltaTime * 60;

                // Check peg collisions
                pegs.forEach((peg, index) => {
                    const dx = ball.x - peg.x;
                    const dy = ball.y - peg.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < ball.radius + peg.radius && ball.lastPegHit !== index) {
                        if (ball.lastPegHit !== null && gameTime - ball.lastCollisionTime < STUCK_TIME_LIMIT) {
                            ball.stuckCounter += 1;
                        } else {
                            ball.stuckCounter = 1;
                        }
                        ball.lastCollisionTime = gameTime;
                        ball.lastPegHit = index;

                        // Handle stuck ball
                        if (ball.stuckCounter >= STUCK_THRESHOLD) {
                            ball.vx += (Math.random() - 0.5) * 4;
                            ball.vy += (Math.random() - 0.5) * 4;
                            ball.stuckCounter = 0;
                        }

                        // Resolve overlap
                        const angle = Math.atan2(dy, dx);
                        const overlap = ball.radius + peg.radius - distance + 0.5;
                        ball.x += Math.cos(angle) * overlap;
                        ball.y += Math.sin(angle) * overlap;

                        // Ensure no overlap after adjustment
                        const newDx = ball.x - peg.x;
                        const newDy = ball.y - peg.y;
                        const newDistance = Math.sqrt(newDx * newDx + newDy * newDy);
                        if (newDistance < ball.radius + peg.radius) {
                            const extraOverlap = ball.radius + peg.radius - newDistance + 0.2;
                            ball.x += Math.cos(angle) * extraOverlap;
                            ball.y += Math.sin(angle) * extraOverlap;
                        }

                        // Apply bounce physics with random horizontal nudge
                        const speed = Math.max(Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy) * BOUNCE_FACTOR, MIN_BOUNCE_SPEED);
                        const horizontalFactor = Math.abs(Math.cos(angle)) * HORIZONTAL_BOOST;
                        ball.vx = -Math.cos(angle) * speed * horizontalFactor + (Math.random() - 0.5) * BOUNCE_HORIZONTAL_NUDGE;
                        ball.vy = -Math.abs(ball.vy) * BOUNCE_FACTOR - MIN_BOUNCE_SPEED * 0.5 + (Math.random() - 0.5) * 0.3;
                    }
                });

                // Check wall collisions
                walls.forEach(wall => {
                    if (ball.x + ball.radius > wall.x && ball.x - ball.radius < wall.x + wall.width &&
                        ball.y + ball.radius > wall.y && ball.y - ball.radius < wall.y + wall.height) {
                        const overlapX = ball.x < wall.x ? (ball.x + ball.radius) - wall.x : (ball.x - ball.radius) - (wall.x + wall.width);
                        ball.x -= overlapX * 1.2;
                        ball.vx = -ball.vx * BOUNCE_FACTOR;
                    }
                });

                // Check slot collisions (ends round)
                slots.forEach(slot => {
                    if (ball.x > slot.x && ball.x < slot.x + slot.width &&
                        ball.y > slot.y && ball.y < slot.y + slot.height) {
                        score += slot.points;
                        totalScore += slot.points;
                        scorePopups.push({
                            x: 125,
                            y: 40,
                            text: `+${slot.points}`,
                            timer: SCORE_POPUP_DURATION,
                            alpha: 1,
                            fontSize: 16
                        });
                        gameState = 'scoring';
                    }
                });

                // Reset last peg hit if far enough
                if (ball.lastPegHit !== null) {
                    const isPeg = typeof ball.lastPegHit === 'number';
                    const obj = isPeg ? pegs[ball.lastPegHit] : ball.lastPegHit;
                    const dx = ball.x - obj.x;
                    const dy = ball.y - obj.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const radius = isPeg ? PEG_RADIUS : obj.radius;
                    if (distance > ball.radius + radius + 10) {
                        ball.lastPegHit = null;
                        ball.stuckCounter = 0;
                    }
                }

                // Handle canvas boundary collisions
                if (ball.x - ball.radius < 0) {
                    ball.x = ball.radius;
                    ball.vx = -ball.vx * BOUNCE_FACTOR;
                }
                if (ball.x + ball.radius > canvas.width) {
                    ball.x = canvas.width - ball.radius;
                    ball.vx = -ball.vx * BOUNCE_FACTOR;
                }
                if (ball.y > canvas.height) ball.y = canvas.height - ball.radius;
            }
        }

        // Render game elements
        function draw() {
            // Clear canvas
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw start screen
            if (gameState === 'menu') {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'white';
                ctx.font = '36px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('Choose a Randomizer', canvas.width / 2, 200);
                randomizerOptions.forEach(option => {
                    const isHovered = mouseX >= option.x && mouseX <= option.x + option.width &&
                                     mouseY >= option.y && mouseY <= option.y + option.height;
                    ctx.fillStyle = isHovered ? '#d3d3d3' : 'white';
                    ctx.strokeStyle = isHovered ? 'red' : 'black';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.rect(option.x, option.y, option.width, option.height);
                    ctx.fill();
                    ctx.stroke();
                    ctx.fillStyle = 'black';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(option.name, option.x + option.width / 2, option.y + 30);
                    ctx.font = '16px Arial';
                    ctx.fillText(option.description, option.x + option.width / 2, option.y + 70);
                });
                ctx.font = '20px Arial';
                ctx.fillText('Tap to select', canvas.width / 2, 750);
                return;
            }

            // Draw ball
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fillStyle = 'red';
            ctx.fill();
            if (bulletCount > 0) {
                // Draw bullet indicator
                ctx.strokeStyle = 'green';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.fillStyle = 'green';
                ctx.beginPath();
                ctx.moveTo(ball.x + ball.radius, ball.y - 5);
                ctx.lineTo(ball.x + ball.radius + 10, ball.y);
                ctx.lineTo(ball.x + ball.radius, ball.y + 5);
                ctx.closePath();
                ctx.fill();
            }

            // Draw obstacles
            obstacles.forEach(obstacle => {
                ctx.beginPath();
                ctx.arc(obstacle.x, obstacle.y, obstacle.radius, 0, Math.PI * 2);
                ctx.fillStyle = obstacle.isShooting ? '#ADD8E6' : 'blue';
                ctx.fill();
                if (obstacle.isShooting) {
                    // Draw gun on shooting obstacles
                    ctx.strokeStyle = 'blue';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.fillStyle = 'blue';
                    const dx = ball.x - obstacle.x;
                    const dy = ball.y - obstacle.y;
                    const angle = Math.atan2(dy, dx) + Math.PI;
                    const gunX = obstacle.x - Math.cos(angle) * obstacle.radius;
                    const gunY = obstacle.y - Math.sin(angle) * obstacle.radius;
                    ctx.beginPath();
                    ctx.moveTo(gunX, gunY - 5);
                    ctx.lineTo(gunX - 10 * Math.cos(angle), gunY - 10 * Math.sin(angle));
                    ctx.lineTo(gunX, gunY + 5);
                    ctx.closePath();
                    ctx.fill();
                }
            });

            // Draw coins
            coins.forEach(coin => {
                ctx.beginPath();
                ctx.arc(coin.x, coin.y, COIN_RADIUS, 0, Math.PI * 2);
                ctx.fillStyle = '#FFD700';
                ctx.fill();
                ctx.strokeStyle = '#DAA520';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.fillStyle = 'black';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('50', coin.x, coin.y);
            });

            // Draw triangle clusters
            triangleClusters.forEach(cluster => {
                ctx.fillStyle = 'green';
                ctx.beginPath();
                ctx.moveTo(cluster.x - 10, cluster.y - 5);
                ctx.lineTo(cluster.x, cluster.y);
                ctx.lineTo(cluster.x - 10, cluster.y + 5);
                ctx.closePath();
                ctx.fill();
            });

            // Draw coin clusters
            coinClusters.forEach(cluster => {
                ctx.fillStyle = '#FFD700';
                ctx.strokeStyle = '#DAA520';
                ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.arc(cluster.x + 5 * i, cluster.y, COIN_RADIUS / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                }
            });

            // Draw triple bullet clusters
            tripleBulletClusters.forEach(cluster => {
                ctx.fillStyle = 'green';
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.moveTo(cluster.x + 5 * i, cluster.y - 5);
                    ctx.lineTo(cluster.x + 5 * i + 10, cluster.y);
                    ctx.lineTo(cluster.x + 5 * i, cluster.y + 5);
                    ctx.closePath();
                    ctx.fill();
                }
            });

            // Draw player-shot triangles
            shotTriangles.forEach(triangle => {
                ctx.fillStyle = 'green';
                ctx.beginPath();
                ctx.moveTo(triangle.x, triangle.y - TRIANGLE_SHOT_SIZE);
                ctx.lineTo(triangle.x + TRIANGLE_SHOT_SIZE * 2, triangle.y);
                ctx.lineTo(triangle.x, triangle.y + TRIANGLE_SHOT_SIZE);
                ctx.closePath();
                ctx.fill();
            });

            // Draw blue shot triangles
            blueShotTriangles.forEach(triangle => {
                ctx.fillStyle = 'blue';
                ctx.beginPath();
                ctx.moveTo(triangle.x, triangle.y - TRIANGLE_SHOT_SIZE);
                ctx.lineTo(triangle.x + TRIANGLE_SHOT_SIZE * 2 * Math.cos(triangle.angle), triangle.y + TRIANGLE_SHOT_SIZE * 2 * Math.sin(triangle.angle));
                ctx.lineTo(triangle.x, triangle.y + TRIANGLE_SHOT_SIZE);
                ctx.closePath();
                ctx.fill();
            });

            // Draw pegs
            pegs.forEach((peg, index) => {
                ctx.beginPath();
                ctx.arc(peg.x, peg.y, peg.radius, 0, Math.PI * 2);
                ctx.fillStyle = ball.lastPegHit === index ? 'orange' : 'blue';
                ctx.fill();
            });

            // Draw slots
            slots.forEach(slot => {
                ctx.fillStyle = slot.points >= HIGH_VALUE_MIN ? '#FFD700' : 'white';
                ctx.beginPath();
                ctx.roundRect(slot.x, slot.y, slot.width, slot.height, 8);
                ctx.fill();
                ctx.fillStyle = slot.points >= HIGH_VALUE_MIN ? 'black' : 'black';
                ctx.font = slot.points >= HIGH_VALUE_MIN ? 'bold 16px Arial' : '16px Arial';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'alphabetic';
                ctx.fillText(slot.points, slot.x + slot.width / 2 - 10, slot.y + slot.height / 2 + 5);
            });

            // Draw walls
            walls.forEach(wall => {
                ctx.fillStyle = 'gray';
                ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
            });

            // Draw coin badge
            if (coinBadge) {
                ctx.globalAlpha = coinBadge.alpha;
                ctx.fillStyle = '#FFD700';
                ctx.strokeStyle = '#DAA520';
                ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.arc(coinBadge.x - 28 + 26 * i, coinBadge.y, 22, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                }
                ctx.fillStyle = 'black';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('COIN BONANZA!', coinBadge.x, coinBadge.y);
                ctx.globalAlpha = 1;
            }

            // Draw triple bullet badge
            if (tripleBulletBadge) {
                ctx.globalAlpha = tripleBulletBadge.alpha;
                ctx.fillStyle = 'green';
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.moveTo(tripleBulletBadge.x - 47 + 32 * i, tripleBulletBadge.y - 22);
                    ctx.lineTo(tripleBulletBadge.x - 47 + 32 * i + 42, tripleBulletBadge.y);
                    ctx.lineTo(tripleBulletBadge.x - 47 + 32 * i, tripleBulletBadge.y + 22);
                    ctx.closePath();
                    ctx.fill();
                }
                ctx.fillStyle = 'white';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('BULLET BONANZA!', tripleBulletBadge.x, tripleBulletBadge.y);
                ctx.globalAlpha = 1;
            }

            // Draw HUD (round, score, bullet bar)
            ctx.fillStyle = 'black';
            ctx.font = '20px Arial';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'alphabetic';
            ctx.fillText(`Round: ${round}/3, Score: ${totalScore}`, 10, 30);
            if (selectedRandomizer) {
                ctx.font = '16px Arial';
                ctx.fillText(`Randomizer: ${selectedRandomizer.name}`, 10, 70);
            }
            if (bulletCount > 0) {
                ctx.fillStyle = 'green';
                ctx.fillRect(10, 50, (bulletCount / MAX_BULLETS) * 100, 10);
            }

            // Draw score pop-ups
            scorePopups.forEach(popup => {
                ctx.font = `${popup.fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = `rgba(211, 211, 211, ${popup.alpha})`;
                ctx.fillText(popup.text, popup.x, popup.y);
            });

            // Draw scoring screen
            if (gameState === 'scoring') {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'white';
                ctx.font = '40px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(round < 3 ? `Score added: ${score}` : `Total Score: ${totalScore}`, canvas.width / 2, canvas.height / 2 - 20);
                ctx.font = '20px Arial';
                ctx.fillText(round < 3 ? 'Tap (or press R) to start the next round' : 'Tap (or press S) to start over', canvas.width / 2, canvas.height / 2 + 20);
            }
        }

        // Initialize menu on load
        initRandomizerMenu();

        // Main game loop
        function gameLoop(time) {
            const deltaTime = (time - lastTime) / 1000;
            lastTime = time;
            update(deltaTime);
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Start game loop
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>